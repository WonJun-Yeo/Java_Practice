package chap10.EX02;

/*	Polymorphism : 다형성
 * 객체의 상속관계에서 여러 데이터 타입으로 변환
 */

class A {
}

class B extends A {
}

class C extends B {
}

class D extends B {
}


public class Polymorphism {

	public static void main(String[] args) {
		// 1. 업캐스팅 : 데이터타입을 명시하지 않아도 자동으로 변환되며, 생략시에 컴파일러가 자동으로 추가한다.
		
		/*	C -> A 타입으로 업캐스팅, C는 A이다. 
		 * 데이터타입을 생략X
		 * ac는 A, B, C의 필드와 메소드를 모두 포함하지만, A의 필드와 메소드에만 접근 가능
		 */
		A ac = (A) new C();	
		
		/* B -> A 타입으로 업캐스팅, B는 A이다. 
		 * 데이터타입을 생략
		 * ab는 A, B 의 필드와 메소드를 모두 포함하지만, A의 필드와 메소드에만 접근 가능
		 */
		A ab = new B();
		
		/* D -> B 타입으로 업캐스팅, D는 B이다.
		 * 데이터타입을 생략
		 * bb는 A, B, D 의 필드와 메소드를 모두 포함하지만, A, B 의 필드와 메소드에만 접근 가능
		 */
		B bb = new D();
		
		/*	C -> C 타입으로 그냥 객체 생성, C는 C이다.
		 * 데이터타입을 생략
		 * c는 A, B, D의 필드와 메소드를 모두 포함하며, 모두 접근 가능
		 */
		C c  = new C();
		
		
		/*	객체 생성이 불가능한 경우 : 부모의 클래스에서 자식의 클래스로 객체를 생성하는 경우, 형제 클래스로 객체를 생성하는 경우
		 * B b = new A();
		 * C cc1 = new B();
		 * D dd1 = new B();
		 * C cd1 = new D()
;		 * 
		 */
		
		
		// 2. 다운캐스팅 : 업캐스팅된 데이터 타입을 하위의 데이터 타입으로 변환하는 것. 데이터타입을 반시드 명시하여야 하며, 컴파일러가 자동으로 추가해주지 않기 때문에 오류가 발생한다.
		
		/*	A -> A 타입으로 그냥 객체 생성, A는 A이다.
		 * 데이터타입을 명시
		 * aa는 A의 필드와 메소드를 포함하며, A의 필드오 메소드에만 접근 가능
		 */
		A aa = new A();
		
		/* 다운 캐스팅으로 객체 생성이 불가능한 경우
		 * B b1 = (B) aa;
		 * C cc2 = (C) aa;
		 * java.lang.ClassCastException : 다운 캐스팅시 객체 내의 해당 타입의 데이터가 존재하지 않는 경우발생하는 오류
		 * 선언 시 오류가 발생하지 않고 실행시 오류가 발생 : 런타임 오류	<-> 프로그램 실행 전 이클립스가 내는 오류 : 컴파일오류
		 */
		
		
		// 업캐스팅 : ac3는 A, B, C의 필드와 메소드를 모두 가지고 있지만, A의 필드와 메소드에만 접근이 가능하다.
		A ac3 = new C();
		
		// A -> B 로 다운캐스팅
		B ac5 = (B) ac3;
		
		// A -> B 로 다운캐스팅
		C ac6 = (C) ac3;
		
		
		
		// 업캐스팅 : ac2는 A, B, D의 필드와 메소드를 모두 가지고 있지만, A의 필드와 메소드에만 접근이 가능하다.
		A ad2 = new D();
		
		// A -> B 로 다운캐스팅
		B bd3 = (B) ad2;
		
		// A -> D 로 다운캐스팅
		D dd4 = (D) ad2;
	}

}
