package chap06_07.EX03;

public class DefaultConstructor {
	// 클래스 내에 포함될 수 있는 요소 : 1. 필드 2. 메소드 3. 생성자 4. 이너클래스
	// 객체를 생성할 때, 반드시 생성자를 호출, A a = new A();
	
	
	/*	생성자의 2가지 특징 : 
	 * 1. 클래스 이름과 동일한 이름을 가진 메소드를 생성자라 한다.
	 * 2. 생성자는 반환 타입이 없다. (메소드는 반환타입이 있다.)
	 * 3. 객체 내의 필드값을 초기화할 때, 오버로딩(Overloading)에 의해서 해당 생성자가 호출
	*/ 
	
	/*	생성자를 사용하는 이유 : 
	 * 객체를 생성할 때, 필드의 값을 초기화(default값 부여) 하면서 객체를 생성하고자 할때 사용 (객체생성)
	 * 클래스 내에서 필드의 초기 값은 일반적으로 할당하지 않는다. (필드값초기화)
	*/ 
	
	/*	기본 생성자 (Default Constructor)
	 * 인풋 매개변수가 없고 실행부의 값도 비어있는 상태의 생성자
	 * 기본 생성자는 생략이 가능하다.
	 * 생략되어 있을 경우, 컴파일러 자동으로 생성해서 컴파일한다.
	 * 클래스 내에 기본 생성자 이외의 다른 생성자가 존재하는 경우, 기본 생성자 호출시 생략되면 안된다.
	 */
	
	
	
	
	public static void main(String[] args) {
		// 객체 생성시 생성자를 반드시 호출해야 한다.
		
		A a = new A();				// 기본 생성자 호출, A() : 기본생성자
		a.work();
		System.out.println();
		
		B b = new B();				// 기본 생성자 호출, B() : 기본생성자
		b.work();
		System.out.println("===========");
		
		// 객체 새성시 생성자를 통해서 필드의 초기값을 할당하고 객체 생성
		
		C c = new C(8);				// 생성자 호출시 기본값을 인풋해서 메모리 필드에 초기값을 구성
		c.work();
		System.out.println();
		
		C cc = new C(5);
		cc.work();
		System.out.println();
		
		C ccc = new C(10);
		ccc.work();
		
		//C cccc = new C(); 		// 오류발생 : 기본생성자가 생략되어있고 다른 생성자가 존재할 때, 기본생성자를 호출하면 오류가 난다.
		System.out.println("=============");
		
		//
		D d = new D();				// 기본생성자 호출
		d.work();					// 객체 필드의 초기값 출력
		System.out.println();
		
		D dd = new D(1, 2, 3);
		dd.work();
		
		D ddd = new D(1,2);		
		
		
	}

}

// 기본 생성자 : class B는 기본생성자가 생략되어 있다.
/*	일반적인 클래스 작성
 * 1. 필드
 * 2. 생성자
 * 3. 메소드
 */

class A {
	int m;							// 필드 : 데이터타입 변수명, 클래스 블락에 선언된 변수, heap 영역에 저장, heep 영역에는 반드시 초기값(default값이 들어감)이 들어가야함, 객체화(인스턴스화)시켜야 사용가능, 예외 : static 키워드를 넣으면 객체화 필요없이 사용가능
	
	A() {}							// 기본생성자 : 생략가능, (1)클래스명과 동일하면서 (2)데이터타입이 없고 (3)매개변수가 없고 (4) 실행부도 없는 메소드를 생성자라 호칭한다.
	
	void work() {					// 메소드 : 리턴타입 메소드명(매개변수) {실행구문}, 호출 : 메소드명(매개변수)
		System.out.println(m);		// m : 메모리의 값을 가지고 온다.
	}
}


class B {
	int m;							// 필드 : 데이터타입 변수명, 클래스 블락에 선언된 변수, heap 영역에 저장, heep 영역에는 반드시 초기값(default값이 들어감)이 들어가야함, 객체화(인스턴스화)시켜야 사용가능, 예외 : static 키워드를 넣으면 객체화 필요없이 사용가능
	
	void work() {					// 메소드 : 리턴타입 메소드명(매개변수) {실행구문}, 호출 : 메소드명(매개변수)
		System.out.println(m);		// m : 메모리의 값을 가지고 온다.
	}
}


// 기본생성자는 생략, 생성자의 매개변수를 받아 메모리의 기본값으로 할당
class C {
	int m;
	
	C (int c) {						// 매개변수가 하나인 생성자
		m = c;
	}
	
	void work() {					// 메소드 : 리턴타입 메소드명(매개변수) {실행구문}, 호출 : 메소드명(매개변수)
		System.out.println(m);		// m : 메모리의 값을 가지고 온다.
	}
}


class D {
	int m, n, l;
	
	D() {}							// 기본 생성자는 생략이 가능, 하지만 다른 생성자가 존재하는 경우 기본생성자를 호출하려면 생략되어선 안된다.
	
	
	D(int m, int l) {
		this.m = m;					// this : 자기 자신의 객체(클래스명)를 뜻한다.지역변수가 아니라 필드의 변수를 알려줌
		this.l = l;
	}
	
	
	D(int a, int b, int c) {		// 매개변수가 세 개인 생성자
		m = a;
		n = b;
		l = c;
	}
	
	void work() {					// work()를 호출시 각각의 메모리의 값을 출력
		System.out.println("m의 값 : " + m + ", n의 값 : " + n + ", l의 값 : " + l);
	}
	
	
	
	
}







